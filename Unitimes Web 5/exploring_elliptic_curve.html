<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>UNITIMES</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="UNITIMES"/>
    <meta name="keywords" content="UNITIMES"/>
    <meta name="author" content="Wade"/>
    <!-- Facebook and Twitter integration -->
    <meta property="og:title" content=""/>
    <meta property="og:image" content=""/>
    <meta property="og:url" content=""/>
    <meta property="og:site_name" content=""/>
    <meta property="og:description" content=""/>
    <meta name="twitter:title" content=""/>
    <meta name="twitter:image" content=""/>
    <meta name="twitter:url" content=""/>
    <meta name="twitter:card" content=""/>

    <!-- Animate.css -->
    <link rel="stylesheet" href="css/animate.css">
    <!-- Icomoon Icon Fonts-->
    <link rel="stylesheet" href="css/icomoon.css">
    <!-- Bootstrap  -->
    <link rel="stylesheet" href="css/bootstrap.css">
    <!-- Magnific Popup -->
    <link rel="stylesheet" href="css/magnific-popup.css">
    <!-- Theme style  -->
    <link rel="stylesheet" href="css/style.css">
    <!-- Modernizr JS -->
    <script src="js/modernizr-2.6.2.min.js"></script>
    <!-- FOR IE9 below -->
    <!--[if lt IE 9]-->
    <script src="js/respond.min.js"></script>
    <![endif]-->
</head>
<body>
<div class="gtco-loader"></div>
<div id="page">
    <nav class="gtco-nav" role="navigation">

        <div class="container">
            <div class="row">
                <div class="col-xs-2 text-left">
                    <div id="gtco-logo"><a href="index.html"><img class="logoimg" src="images/logo_white.svg"
                    ></a></div>
                </div>
                <div class="col-xs-10 text-right menu-1">
                    <ul>
                        <li><a href="index.html">HOME</a></li>
                        <li><a href="interview.html">Unitalks</a></li>
                        <li><a href="news.html">News</a></li>
                        <li><a href="knowledge.html">Knowledge</a></li>
                        <li><a href="events.html">Events</a></li>
                        <li><a href="about.html">UNITIMES</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </nav>
    <header id="gtco-header" class="gtco-cover" role="banner" style="background-image:url(images/img_4.jpg);"
            data-stellar-background-ratio="1.0">
        <div class="overlay"></div>
        <div class="container">
            <div class="row">
                <div class="col-md-8 text-left">
                    <div class="display-t">
                        <div class="display-tc animate-box" data-animate-effect="fadeInUp">
                            <!--<span class="date-post">11 / 9 / 2017</span>-->
                            <h1 class="mb30"><a href="#"> Exploring Elliptic Curve Pairings
                                <h3 style="font-size: 40px; color: white;">Trigger warning: math!</h3>
                            </a></h1>
                            <span class="date-post">9 / 3 / 2017</span>
                            <p>Author: <a href="#" class="text-link"> Vitalik Buterin
                            </a></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>
    <div id="gtco-maine">
        <div class="container">
            <div class="row row-pb-md">
                <div class="col-md-12">
                    <article class="mt-negative">
                        <div class="text-left content-article">
                            <div class="row">
                                <div class="cp-r animate-box">
                                    <h1>Exploring Elliptic Curve Pairings
                                    </h1>
                                    <p>Trigger warning: math!
                                    </p>
                                    <p> By Vitalik Buterin <br>
                                        9 / 3 / 2017</p>
                                    <!--<span class="date-post">9 / 3 / 2017</span>-->
                                    <img class="img_1" src="images/z3.png">
                                    <br>One of the key cryptographic primitives behind various constructions, including
                                    deterministic threshold signatures, zk-SNARKs and other simpler forms of
                                    zero-knowledge proofs is the elliptic curve pairing. Elliptic curve pairings (or
                                    “bilinear maps”) are a recent addition to a 30-year-long history of using elliptic
                                    curves for cryptographic applications including encryption and digital signatures;
                                    pairings introduce a form of “encrypted multiplication”, greatly expanding what
                                    elliptic curve-based protocols can do. The purpose of this article will be to go
                                    into elliptic curve pairings in detail, and explain a general outline of how they
                                    work.
                                    <br><br>You’re not expected to understand everything here the first time you read
                                    it, or even the tenth time; this stuff is genuinely hard. But hopefully this article
                                    will give you at least a bit of an idea as to what is going on under the hood.
                                    <br><br>Elliptic curves themselves are very much a nontrivial topic to understand,
                                    and this article will generally assume that you know how they work; if you do not, I
                                    recommend this article here as a primer:<a>https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/</a>.
                                    As a quick summary, elliptic curve cryptography involves mathematical objects called
                                    “points” (these are literal two-dimensional points with (x, y) coordinates), with
                                    special formulas for adding and subtracting them (ie. for calculating the
                                    coordinates of R = P + Q), and you can also multiply a point by an integer (ie. P *
                                    n = P + P + … + P, though there’s a much faster way to compute it if n is big).
                                    <img class="article-imgs" src="img/q2.png"/>
                                    Here’s how point addition looks like graphically.
                                    <br><br>There exists a special point called the “point at infinity” (O), the
                                    equivalent of zero in point arithmetic; it’s always the case that P + O = P. Also, a
                                    curve has an “order”; there exists a number n such that P * n = O for any P (and of
                                    course, P * (n+1) = P, P * (7*n + 5) = P * 5, and so on). There is also some
                                    commonly agreed upon “generator point” G, which is understood to in some sense
                                    represent the number 1. Theoretically, any point on a curve (except O) can be G; all
                                    that matters is that G is standardized.
                                    <br><br>Pairings go a step further in that they allow you to check certain kinds of
                                    more complicated equations on elliptic curve points — for example, if P = G * p, Q =
                                    G * q and R = G * r, you can check whether or not p * q = r, having just P, Q and R
                                    as inputs. This might seem like the fundamental security guarantees of elliptic
                                    curves are being broken, as information about p is leaking from just knowing P, but
                                    it turns out that the leakage is highly contained — specifically, the <a
                                        href="https://en.wikipedia.org/wiki/Decisional_Diffie%E2%80%93Hellman_assumption">decisional
                                    Diffie Hellman problem</a> is easy, but the computational Diffie Hellman problem
                                    (knowing P and Q in the above example, computing R = G * p * q) and the <a
                                        href="https://en.wikipedia.org/wiki/Discrete_logarithm">discrete logarithm
                                    problem</a>(recovering p from P) remain computationally infeasible (at least, if
                                    they were before).
                                    <br><br>A third way to look at what pairings do, and one that is perhaps most
                                    illuminating for most of the use cases that we are about, is that if you view
                                    elliptic curve points as one-way encrypted numbers (that is, encrypt(p) = p * G =
                                    P), then whereas traditional elliptic curve math lets you check linear constraints
                                    on the numbers (eg. if P = G * p, Q = G * q and R = G * r, checking 5 * P + 7 * Q =
                                    11 * R is really checking that 5 * p + 7 * q = 11 * r), pairings let you
                                    check quadratic constraints (eg. checking e (P, Q) * e (G, G * 5) = 1
                                    is really checking that p * q + 5 = 0). And going up to quadratic is enough to let
                                    us work with deterministic threshold signatures, quadratic arithmetic programs and
                                    all that other good stuff.
                                    <br><br>Now, what is this funny e (P, Q) operator that we introduced above? This is
                                    the pairing. Mathematicians also sometimes call it a bilinear map; the word
                                    “bilinear” here basically means that it satisfies the constraints:
                                    <br><br>e (P, Q + R) = e(P, Q) * e(P, R)
                                    <br><br>e(P + S, Q) = e(P, Q) * e(S, Q)
                                    <br><br>Note that + and * can be arbitrary operators; when you’re creating fancy new
                                    kinds of mathematical objects, abstract algebra doesn’t care how + and *
                                    are defined, as long as they are consistent in the usual ways, eg. a + b = b + a, (a
                                    * b) * c = a * (b * c) and (a * c) + (b * c) = (a + b) * c.
                                    <br><br>If P, Q, R and S were simple numbers, then making a simple pairing is easy:
                                    we can do e(x, y) = 2^xy. Then, we can see:
                                    <br><br>e(3, 4+ 5) = 2^(3 * 9) = 2²⁷
                                    <br><br>e(3, 4) * e(3, 5) = 2^(3 * 4) * 2^(3 * 5) = 2¹² * 2¹⁵ = 2²⁷
                                    <br><br>It’s bilinear!
                                    <br><br>However, such simple pairings are not suitable for cryptography because the
                                    objects that they work on are simple integers and are too easy to analyze; integers
                                    make it easy to divide, compute logarithms, and make various other computations;
                                    simple integers have no concept of a “public key” or a “one-way function”.
                                    Additionally, with the pairing described above you can go backwards - knowing x, and
                                    knowing e(x, y), you can simply compute a division and a logarithm to determine y.
                                    We want mathematical objects that are as close as possible to “black boxes”, where
                                    you can add, subtract, multiply and divide, but do nothing else. This is where
                                    elliptic curves and elliptic curve pairings come in.
                                    <br><br>It turns out that it is possible to make a bilinear map over elliptic curve
                                    points — that is, come up with a function e(P, Q) where the inputs P and Q are
                                    elliptic curve points, and where the output is what’s called an F_p¹² element (at
                                    least in the specific case we will cover here; the specifics differ depending on the
                                    details of the curve, more on this later), but the math behind doing so is quite
                                    complex.
                                    <br><br>First, let’s cover prime fields and extension fields. The pretty elliptic
                                    curve in the picture earlier in this post only looks that way if you assume that the
                                    curve equation is defined using regular real numbers. However, if we actually use
                                    regular real numbers in cryptography, then you can use logarithms to “go backwards”,
                                    and everything breaks; additionally, the amount of space needed to actually store
                                    and represent the numbers may grow arbitrarily. Hence, we instead use numbers in
                                    a prime field.
                                    <br><br>A prime field consists of the set of numbers 0, 1, 2… p-1, where p is prime,
                                    and the various operations are defined as follows:
                                    <br><br>a + b: (a + b) % p
                                    <br><br>a * b: (a * b) % p
                                    <br><br>a - b: (a - b) % p
                                    <br><br>a / b: (a * b^(p-2)) % p
                                    <br><br>Basically, all math is done modulo p (see <a
                                        href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic">here</a> for
                                    an introduction to modular math). Division is a special case; normally, 3/2 is not
                                    an integer, and here we want to deal only with integers, so we instead try to find
                                    the number x such that x * 2 = 3, where * of course refers to modular multiplication
                                    as defined above. Thanks to <a
                                        href="https://en.wikipedia.org/wiki/Fermat's_little_theorem">Fermat’s little
                                    theorem</a>, the exponentiation trick shown above does the job, but there is also a
                                    faster way to do it, using the <a
                                        href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm">Extended
                                    Euclidean Algorithm</a>. Suppose p = 7; here are a few examples:
                                    <br><br>2 + 3 = 5 % 7 = 5
                                    <br><br>4 + 6 = 10 % 7 = 3
                                    <br><br>2 - 5 = -3 % 7 = 4
                                    <br><br>6 * 3 = 18 % 7 = 4
                                    <br><br>3 / 2 = (3 * 2^5) % 7 = 5
                                    <br><br>5 * 2 = 10 % 7 = 3
                                    <br><br>If you play around with this kind of math, you’ll notice that it’s perfectly
                                    consistent and satisfies all of the usual rules. The last two examples above show
                                    how (a / b) * b = a; you can also see that (a + b) + c = a + (b + c), (a + b) * c =
                                    a * c + b * c, and all the other high school algebraic identities you know and love
                                    continue to hold true as well. In elliptic curves in reality, the points and
                                    equations are usually computed in prime fields.
                                    <br><br>Now, let’s talk about extension fields. You have probably already seen an
                                    extension field before; the most common example that you encounter in math textbooks
                                    is the field of complex numbers, where the field of real numbers is “extended” with
                                    the additional element sqrt(-1) = i. Basically, extension fields work by taking an
                                    existing field, then “inventing” a new element and defining the relationship between
                                    that element and existing elements (in this case, i² + 1 = 0), making sure that this
                                    equation does not hold true for any number that is in the original field, and
                                    looking at the set of all linear combinations of elements of the original field and
                                    the new element that you have just created.


                                    <img class="article-imgs" src="img/q3.png"/>
                                    We can do extensions of prime fields too; for example, we can extend the prime field
                                    mod 7 that we described above with i, and then we can do:
                                    <br><br>(2 + 3i) + (4 + 2i) = 6 + 5i
                                    <br><br>(5 + 2i) + 3 = 1 + 2i
                                    <br><br>(6 + 2i) * 2 = 5 + 4i
                                    <br><br>4i * (2 + i) = 3 + i
                                    <br><br>That last result may be a bit hard to figure out; what happened there was
                                    that we first decompose the product into 4i * 2 + 4i * i, which gives 8i - 4, and
                                    then because we are working in mod 7 math that becomes i + 3. To divide, we do:
                                    <br><br>a / b: (a * b^(p^2-2)) % p
                                    <br><br>Note that the exponent for Fermat’s little theorem is now p² instead of p,
                                    though once again if we want to be more efficient we can also instead extend the
                                    Extended Euclidean Algorithm to do the job. Note that x^(p² - 1) = 1 for any x in
                                    this field, so we call p² - 1 the “order of the multiplicative group in the field”.
                                    <br><br>With real numbers, the <a
                                        href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_algebra">Fundamental
                                    Theorem of Algebra</a> ensures that the quadratic extension that we call the complex
                                    numbers is “complete” — you cannot extend it further, because for any mathematical
                                    relationship (at least, any mathematical relationship defined by an algebraic
                                    formula) that you can come up with between some new element j and the existing
                                    complex numbers, it’s possible to come up with at least one complex number that
                                    already satisfies that relationship. With prime fields, however, we do not have this
                                    issue, and so we can go further and make cubic extensions (where the mathematical
                                    relationship between some new element w and existing field elements is a cubic
                                    equation, so 1, w and w² are all linearly independent of each other), higher-order
                                    extensions, extensions of extensions, etc. And it is these kinds of supercharged
                                    modular complex numbers that elliptic curve pairings are built on.
                                    <br><br>For those interested in seeing the exact math involved in making all of
                                    these operations written out in code, prime fields and field extensions are
                                    implemented here:<a>https://github.com/ethereum/research/blob/master/zksnark/bn128_field_elements.py</a>
                                    <br><br>Now, on to elliptic curve pairings. An elliptic curve pairing (or rather,
                                    the specific form of pairing we’ll explore here; there are also other types of
                                    pairings, though their logic is fairly similar) is a map G2 x G1 -> Gt, where:
                                    <br><br>• G1 is an elliptic curve, where points satisfy an equation of the form y² =
                                    x³ + b, and where both coordinates are elements of F_p (ie. they are simple numbers,
                                    except arithmetic is all done modulo some prime number)
                                    <br><br>• G2 is an elliptic curve, where points satisfy the same equation as G1,
                                    except where the coordinates are elements of F_p¹² (ie. they are the supercharged
                                    complex numbers we talked about above; we define a new “magic number” w, which is
                                    defined by a 12th degree polynomial likew^12 - 18 * w^6 + 82 = 0)
                                    <br><br>• Gt is the type of object that the result of the elliptic curve goes into.
                                    In the curves that we look at, Gt is F_p¹² (the same supercharged complex number as
                                    used in G2)
                                    <br><br>The main property that it must satisfy is bilinearity, which in this context
                                    means that:
                                    <br><br>• e(P, Q + R) = e(P, Q) * e(P, R)
                                    <br><br>• e(P + Q, R) = e(P, R) * e(Q, R)
                                    <br><br>There are two other important criteria:
                                    <br><br>• Efficient computability (eg. we can make an easy pairing by simply taking
                                    the discrete logarithms of all points and multiplying them together, but this is as
                                    computationally hard as breaking elliptic curve cryptography in the first place, so
                                    it doesn’t count)
                                    <br><br>• Non-degeneracy (sure, you could just define e(P, Q) = 1, but that’s not a
                                    particularly useful pairing)
                                    <br><br>So how do we do this?
                                    <br><br>The math behind why pairing functions work is quite tricky and involves
                                    quite a bit of advanced algebra going even beyond what we’ve seen so far, but I’ll
                                    provide an outline. First of all, we need to define the concept of a divisor,
                                    basically an alternative way of representing functions on elliptic curve points. A
                                    divisor of a function basically counts the zeroes and the infinities of the
                                    function. To see what this means, let’s go through a few examples. Let us fix some
                                    point P = (P_x, P_y), and consider the following function:
                                    <br><br>f(x, y) = x - P_x
                                    <br><br>The divisor is [P] + [-P] - 2 * [O] (the square brackets are used to
                                    represent the fact that we are referring to the presence of the point P in the set
                                    of zeroes and infinities of the function, not the point P itself; [P] + [Q]
                                    is not the same thing as [P + Q]). The reasoning is as follows:
                                    <br><br>• The function is equal to zero at P, since x is P_x, so x - P_x = 0
                                    <br><br>• The function is equal to zero at -P, since -P and P share the same x
                                    coordinate
                                    <br><br>• The function goes to infinity as x goes to infinity, so we say the
                                    function is equal to infinity at O. There’s a technical reason why this infinity
                                    needs to be counted twice, so O gets added with a “multiplicity” of -2 (negative
                                    because it’s an infinity and not a zero, two because of this double counting).
                                    <br><br>The technical reason is roughly this: because the equation of the curve is
                                    x³ = y² + b, y goes to infinity “1.5 times faster” than x does in order for y² to
                                    keep up with x³; hence, if a linear function includes only x then it is represented
                                    as an infinity of multiplicity 2, but if it includes y then it is represented as an
                                    infinity of multiplicity 3.
                                    <br><br>Now, consider a “line function”:
                                    <br><br>ax + by + c = 0
                                    <br><br>Where a, b and c are carefully chosen so that the line passes through points
                                    P and Q. Because of how elliptic curve addition works (see the diagram at the top),
                                    this also means that it passes through -P-Q. And it goes up to infinity dependent on
                                    both x and y, so the divisor becomes [P]+ [Q] + [-P-Q] - 3 * [O].
                                    <img class="article-imgs" src="img/q4.png"/>
                                    We know that every “rational function” (ie. a function defined only using a finite
                                    number of +, -, * and / operations on the coordinates of the point) uniquely
                                    corresponds to some divisor, up to multiplication by a constant (ie. if two
                                    functions F and G have the same divisor, then F = G * k for some constant k).
                                    <br><br>For any two functions F and G, the divisor of F * G is equal to the divisor
                                    of F plus the divisor of G (in math textbooks, you’ll see (F * G) = (F) + (G)), so
                                    for example if f(x, y) = P_x - x, then (f³) = 3 * [P] + 3 * [-P] - 6 * [O]; P and -P
                                    are “triple-counted” to account for the fact that f³ approaches 0 at those points
                                    “three times as quickly” in a certain mathematical sense.
                                    <br><br>Note that there is a theorem that states that if you “remove the square
                                    brackets” from a divisor of a function, the points must add up to O ([P] + [Q] +
                                    [-P-Q] - 3 * [O] clearly fits, as P + Q - P - Q - 3 * O = O), and any divisor that
                                    has this property is the divisor of a function.
                                    <br><br>Now, we’re ready to look at Tate pairings. Consider the following functions,
                                    defined via their divisors:
                                    <br><br>• (F_P) = n * [P] - n * [O], where n is the order of G1, ie. n * P = O for
                                    any P
                                    <br><br>• (F_Q) = n * [Q] - n * [O]
                                    <br><br>• (g) = [P + Q] - [P] - [Q] + [O]
                                    <br><br>Now, let’s look at the product F_P * F_Q * g^n. The divisor is:
                                    <br><br>n * [P] - n * [O] + n * [Q] - n * [O] + n * [P + Q] - n * [P] - n * [Q] + n
                                    * [O]
                                    <br><br>Which simplifies neatly to:
                                    <br><br>n * [P + Q] - n * [O]
                                    <br><br>Notice that this divisor is of exactly the same format as the divisor for
                                    F_P and F_Q above. Hence, F_P * F_Q * g^n = F_(P + Q).
                                    <br><br>Now, we introduce a procedure called the “final exponentiation” step, where
                                    we take the result of our functions above (F_P, F_Q, etc.) and raise it to the power
                                    z = (p¹² - 1) / n, where p¹² - 1 is the order of the multiplicative group in F_p¹²
                                    (ie. for any x ϵ F_p¹², x^(p¹² - 1) = 1). Notice that if you apply this
                                    exponentiation to any result that has already been raised to the power of n, you get
                                    an exponentiation to the power of p¹² - 1, so the result turns into 1. Hence, after
                                    final exponentiation, g^n cancels out and we get F_P^z * F_Q^z = F_(P + Q)^z.
                                    There’s some bilinearity for you.
                                    <br><br>Now, if you want to make a function that’s bilinear in both arguments, you
                                    need to go into spookier math, where instead of taking F_P of a value directly, you
                                    take F_P of a divisor, and that’s where the full “Tate pairing” comes from. To prove
                                    some more results you have to deal with notions like “linear equivalence” and “Weil
                                    reciprocity”, and the rabbit hole goes on from there. You can find more reading
                                    material on all of this <a
                                        href="http://www.math.ru.nl/~bosma/Students/MScThesis_DennisMeffert.pdf">here</a> and <a
                                        href="http://people.cs.nctu.edu.tw/~rjchen/ECC2012S/Elliptic Curves Number Theory And Cryptography 2n.pdf">here</a>.
                                    <br><br>For an implementation of a modified version of the Tate pairing, called the
                                    optimal Ate paring, see <a
                                        href="https://github.com/ethereum/research/blob/master/zksnark/bn128_pairing.py">here</a>.
                                    The code implements <a href="https://crypto.stanford.edu/pbc/notes/ep/miller.html">Miller’s
                                    algorithm</a>, which is needed to actually compute F_P.
                                    <br><br>Note that the fact pairings like this are possible is somewhat of a mixed
                                    blessing: on the one hand, it means that all the protocols we can do with pairings
                                    become possible, but is also means that we have to be more careful about what
                                    elliptic curves we use.
                                    <br><br>Every elliptic curve has a value called an embedding degree; essentially,
                                    the smallest k such that p^k - 1 is a multiple of n (where p is the prime used for
                                    the field and n is the curve order). In the fields above, k = 12, and in the fields
                                    used for traditional ECC (ie. where we don’t care about pairings), the embedding
                                    degree is often extremely large, to the point that pairings are computationally
                                    infeasible to compute; however, if we are not careful then we can generate fields
                                    where k = 4 or even 1.
                                    <br><br>If k = 1, then the “discrete logarithm” problem for elliptic curves
                                    (essentially, recovering p knowing only the point P = G * p, the problem that you
                                    have to solve to “crack” an elliptic curve private key) can be reduced into a
                                    similar math problem over F_p, where the problem becomes much easier (this is called
                                    the <a href="https://crypto.stanford.edu/pbc/notes/elliptic/movattack.html">MOV
                                    attack</a>); using curves with am embedding degree of 12 or higher ensures that this
                                    reduction is either unavailable, or that solving the discrete log problem over
                                    pairing results is at least as hard as recovering a private key from a public key
                                    “the normal way” (ie. computationally infeasible). Do not worry; all standard curve
                                    parameters have been thoroughly checked for this issue.
                                    <br><br>Stay tuned for a mathematical explanation of how zk-SNARKs work, coming
                                    soon.
                                    <br><br>Special thanks to Christian Reitwiessner, Ariel Gabizon (from Zcash) and
                                    Alfred Menezes for reviewing and making corrections.

                                    <br><br>Source:

                                    <a href="https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627">https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627</a>

                                </div>
                            </div>
                        </div>
                    </article>
                </div>
            </div>

        </div>
    </div>
    <footer id="gtco-footer" class="article-foot" role="contentinfo">
        <div class="container">
            <div class="row copyright">
                <div class="col-md-12 text-center">
                    <div class="copyrighttxt">&copy; UNITIMES. All Rights Reserved.</div>

                </div>
            </div>
        </div>
    </footer>
</div>
<div class="gototop js-top">
    <a href="#" class="js-gotop"><i class="icon-arrow-up"></i></a>
</div>
<!-- jQuery -->
<script src="js/jquery.min.js"></script>
<!-- jQuery Easing -->
<script src="js/jquery.easing.1.3.js"></script>
<!-- Bootstrap -->
<script src="js/bootstrap.min.js"></script>
<!-- Waypoints -->
<script src="js/jquery.waypoints.min.js"></script>
<!-- Stellar -->
<script src="js/jquery.stellar.min.js"></script>
<!-- Main -->
<script src="js/main.js"></script>
</body>
</html>
